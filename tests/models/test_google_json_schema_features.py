"""Test Google's enhanced JSON Schema features (November 2025).

These tests verify that the GoogleJsonSchemaTransformer correctly handles the new
JSON Schema features announced by Google for Gemini 2.5+ models.

Note: The enhanced features (additionalProperties, $ref, etc.) are only supported
in Vertex AI, not in the Generative Language API (google-gla).
"""

from typing import Any

from pydantic import BaseModel, Field

from pydantic_ai.profiles.google import GoogleJsonSchemaTransformer


class TestSchemaTransformation:
    """Test that schemas are transformed correctly without stripping supported features."""

    def test_title_field_preserved(self):
        """Verify that title fields are preserved in transformed schemas."""

        class Model(BaseModel):
            name: str = Field(title='User Name')
            age: int = Field(title='Age in Years')

        schema = Model.model_json_schema()
        transformer = GoogleJsonSchemaTransformer(schema)
        transformed = transformer.walk()

        # Title should be preserved
        assert transformed['properties']['name']['title'] == 'User Name'
        assert transformed['properties']['age']['title'] == 'Age in Years'

    def test_additional_properties_preserved(self):
        """Verify that additionalProperties is preserved for dict types."""

        class Model(BaseModel):
            metadata: dict[str, str] | None = None

        schema = Model.model_json_schema()
        transformer = GoogleJsonSchemaTransformer(schema)
        transformed = transformer.walk()

        # Find the metadata property definition (could be in a oneOf due to nullable)
        metadata_schema = transformed['properties']['metadata']
        if 'oneOf' in metadata_schema:
            # Find the object type in the oneOf
            for option in metadata_schema['oneOf']:
                if option.get('type') == 'object':
                    metadata_schema = option
                    break

        # additionalProperties should be preserved
        assert 'additionalProperties' in metadata_schema

    def test_ref_and_defs_preserved(self):
        """Verify that $ref and $defs are preserved for recursive schemas."""

        class TreeNode(BaseModel):
            value: int
            children: list['TreeNode'] | None = None

        schema = TreeNode.model_json_schema()
        transformer = GoogleJsonSchemaTransformer(schema)
        transformed = transformer.walk()

        # Should have $defs with TreeNode definition
        assert '$defs' in transformed
        assert 'TreeNode' in transformed['$defs']

        # Should have $ref in the children property
        children_prop = transformed['$defs']['TreeNode']['properties']['children']
        # Could be in oneOf due to nullable
        if 'oneOf' in children_prop:
            # Find the array type
            for option in children_prop['oneOf']:
                if option.get('type') == 'array':
                    assert '$ref' in option['items']
                    break
        else:
            assert '$ref' in children_prop['items']

    def test_anyof_preserved(self):
        """Verify that anyOf is preserved in union types."""

        class Model(BaseModel):
            value: int | str

        schema = Model.model_json_schema()
        transformer = GoogleJsonSchemaTransformer(schema)
        transformed = transformer.walk()

        # Should have anyOf for the union
        assert 'anyOf' in transformed['properties']['value']

    def test_oneof_not_converted_to_anyof(self):
        """Verify that oneOf is preserved when generated by Pydantic (discriminated unions).

        Note: Simple unions generate anyOf, but discriminated unions generate oneOf.
        This test verifies we don't convert oneOf to anyOf.
        """
        from typing import Literal

        class Cat(BaseModel):
            type: Literal['cat']
            meows: int

        class Dog(BaseModel):
            type: Literal['dog']
            barks: int

        class Pet(BaseModel):
            pet: Cat | Dog = Field(discriminator='type')

        schema = Pet.model_json_schema()
        # Pydantic generates oneOf for discriminated unions
        assert 'oneOf' in schema['properties']['pet']

        transformer = GoogleJsonSchemaTransformer(schema)
        transformed = transformer.walk()

        # oneOf should be preserved (not converted to anyOf)
        # Note: discriminator field will be stripped, but oneOf structure remains
        assert 'oneOf' in transformed['properties']['pet']

    def test_min_max_preserved(self):
        """Verify that minimum and maximum constraints are preserved."""

        class Model(BaseModel):
            temperature: float = Field(ge=0, le=100)
            count: int = Field(ge=1, le=1000)

        schema = Model.model_json_schema()
        transformer = GoogleJsonSchemaTransformer(schema)
        transformed = transformer.walk()

        # minimum and maximum should be preserved
        assert transformed['properties']['temperature']['minimum'] == 0
        assert transformed['properties']['temperature']['maximum'] == 100
        assert transformed['properties']['count']['minimum'] == 1
        assert transformed['properties']['count']['maximum'] == 1000

    def test_exclusive_min_max_stripped(self):
        """Verify that exclusiveMinimum and exclusiveMaximum are stripped."""

        class Model(BaseModel):
            value: float = Field(gt=0, lt=100)

        schema = Model.model_json_schema()
        transformer = GoogleJsonSchemaTransformer(schema)
        transformed = transformer.walk()

        # exclusiveMinimum and exclusiveMaximum should be stripped
        value_schema = transformed['properties']['value']
        assert 'exclusiveMinimum' not in value_schema
        assert 'exclusiveMaximum' not in value_schema

    def test_discriminator_stripped(self):
        """Verify that discriminator field is stripped."""
        from typing import Literal

        class Cat(BaseModel):
            pet_type: Literal['cat']
            meows: int

        class Dog(BaseModel):
            pet_type: Literal['dog']
            barks: int

        class Owner(BaseModel):
            pet: Cat | Dog = Field(discriminator='pet_type')

        schema = Owner.model_json_schema()
        transformer = GoogleJsonSchemaTransformer(schema)
        transformed = transformer.walk()

        # Verify discriminator is stripped from all nested schemas
        def check_no_discriminator(obj: dict[str, Any]) -> None:
            if isinstance(obj, dict):
                assert 'discriminator' not in obj, 'discriminator should be stripped'
                for value in obj.values():
                    if isinstance(value, dict):
                        check_no_discriminator(value)  # type: ignore[arg-type]
                    elif isinstance(value, list):
                        for item in value:  # type: ignore[reportUnknownVariableType]
                            if isinstance(item, dict):
                                check_no_discriminator(item)  # type: ignore[arg-type]

        check_no_discriminator(transformed)

    def test_nullable_preserved(self):
        """Verify that nullable fields are handled correctly.

        Pydantic uses 'nullable': True for optional fields with simplify_nullable_unions.
        """

        class Model(BaseModel):
            optional_field: str | None = None

        schema = Model.model_json_schema()
        transformer = GoogleJsonSchemaTransformer(schema)
        transformed = transformer.walk()

        # GoogleJsonSchemaTransformer uses simplify_nullable_unions=True
        # which converts Union[str, None] to {"type": "string", "nullable": True}
        field_schema = transformed['properties']['optional_field']
        assert field_schema.get('nullable') is True or 'oneOf' in field_schema
